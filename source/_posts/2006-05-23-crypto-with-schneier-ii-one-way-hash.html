---
layout: post
title: "Crypto with Schneier II: One Way Hash"
date: 2006-05-23T19:28:00-07:00
---

<div class='post'>
<span style="color: rgb(51, 51, 255);font-size:180%;" >{</span><br /><br />My reading of Schneier has continued.  He still proves to be a very accomodating writer; consider the following on the "One-Time Pad," a encryption scheme that can be literally unbreakable:<br /><br /><blockquote>"Many Soviet spy messages to agents were encrypted using one-time pads.  These messages are still secure today and will remain that way forever. It doesn't matter how long the supercomputers work on the problem. Even after the aliens from Andromeda land with their massive spaceships and undreamed-of computing power, they will not be able to read the Soviet spy messages encrypted with one-time pads (unless they can also go back in time and get the one-time pads)."</blockquote>In the second chapter he is discussing the basics of protocols and describes the one-way hash: "a function, mathematical or otherwise, that takes a variable-length input string (pre-image) and converts it to a fixed-length output string.  Essentially, a computed hash represents a fixed length byte array that is unique for whatever its input stream was.  This is interesting and useful beyond cryptography. <br /><br />Here's a simple idea from Steve Oualline's book "<a href="http://www.nostarch.com/frameset.php?startat=wcps"><span style="font-style: italic;">Wicked Cool Perl Scripts</span></a>," but implemented in C#: you can compute a hash to check to see if two files are different or the same.<br /><br />The following code uses the System.IO and System.Security.Cryptography namespaces:<br /><br />        private static bool CompareFiles(string path1, string path2) {<br />            byte[] hash1 = GetMD5Hash(path1);<br />            byte[] hash2 = GetMD5Hash(path2);<br />            for (int i = 0; i < hash1.Length; i++)<br />            {<br />                if (hash1[i] != hash2[i])<br />                {<br />                    return false;<br />                }<br />            }<br />            return true;<br />        }<br /><br />        private static byte[] GetMD5Hash(string pth)<br />        {<br />            MD5 hasher = MD5.Create();<br />            byte[] fileBytes = File.ReadAllBytes(pth);<br />            byte[] hash = hasher.ComputeHash(fileBytes);<br />            return hash;<br />        }<br /><br />I was curious about the performance of this technique - I was originally testing it on 40MB files.  I extracted some old database backup files - about 200MB a piece and the comparison took somewhere on the order of 20 seconds.  My laptop has a P4  3Ghz with  1GB of RAM.  Nice, but not out of the ordinary (especially these days).  I've also got suspicions that the speed was not necessarily on the hash computation, but rather on reading out the byte array in the file. I'll test sometime to see...<br /><br /><span style="font-size:180%;"><span style="color: rgb(51, 51, 255);">}</span></span></div>
