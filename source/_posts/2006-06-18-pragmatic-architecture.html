---
layout: post
title: "Pragmatic Architecture"
date: 2006-06-18T19:16:00-07:00
---

<div class='post'>
<span style="color: rgb(51, 51, 255);font-size:180%;" >{</span><br /><br /><a href="http://blogs.prenia.com/cathi/">Cathi Gero</a> and <a href="http://www.tedneward.com/default.aspx">Ted Neward</a> had a session on what they call "pragmatic architecture" - the fuzzy definition of which was architecture that maintains ideals until the consequences outweigh them.<br /><br />It was interesting to get this high level at TechEd; most of the sessions I went to were very technical where this was a balance between philosophy and a general approach to developing software.<br /><br />One of the first thing they went after was the recent infatuation people on the architectural level have had with "<a href="http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29">design patterns</a>."  According to them, a cut and paste approach to design patterns is not the path to success - and although I haven't immersed myself in the design patterns world, I doubt it's proponents probably leave some room for flexibility in implementation. <br /><br />According to Cathi and Ted, the goals of a software architect were twofold:<br />1. Functional Requirements (Business needs, raw functionality)<br />2. Non-functional Requirements (the "ities": scalability, maintainability, extensibility, and so on)<br /><br />Their approach in being pragmatic about architecture was to leverage a vocabulary, not as a means to accomplish the goals of software architecture, but as a lexicon for strategies and tactics in accomplishing those two main goals.  They covered what they called the 6 elements of architecture and examples of approaches (patterns?) that lend themselves to the software of the solution.<br /><br />Here are the 6 architectural "elements:"<br /><br />1. Communication<br />2. Presentation (the front end)<br />3. State Management (how the data are stored)<br />4. Processing<br />5. Resource Management<br />6. Tools<br /><br />For each of the 6 they presented examples of what we see with most modern software.  Under Communication, for example, they listed what they call as a "three part tuple:"<br /><br />1. Transport<br />TCP, UDP, other network protocols<br />2. Exchange<br />Data can be exchanged using request/response, asynchronous, fire and forget, amongst others<br />3. Format<br />XML, Text, JSON, Binary, and so on.<br /><br />Presentation has to do with the interface for the user.  Some examples given here were Console, Graphical Interface, and Markup.<br /><br />The State Model to apply in the application in pragmatic language is either durable (available always) or transient (available only certain times).  Another consideration for State Management is the "shape" of the data: objects, relational, heirarchical, etc... Finally when considering the State Model there was the notion of where the data was: client, server, elsewhere...<br /><br />Processing used in the application, some examples of implementation they gave were: Procedural, Imperative, Concurrent, Parallel, and Transactional.  On the processing side, however, some higher level descriptions of approaches included: Divide and Conquer, Recursive, Event based, Shared Queue, amongst others.<br /><br />Resource Management had to do with persistence of data and configuration. Some styles discussed for this was locator / registry, discovery, injected, and a very sophisticated term for "hard coding" called <span style="font-style: italic;">a priori</span>.<br /><br />Tools to consider in being pragmatic could be the programming language, development environment, frameworks, code generation, amongst others.<br /><br />I'm not sure if this stuff originated with Cathi and Ted, but it's very useful in coming up with a high level picture of how software will work. Although most of what I've worked with recently fits under the umbrella of "web application" it would be very useful to approach new projects with this catalog and the set of approaches beneath each item in mind.<br /><br />This entire session is available as <a href="http://msevents.microsoft.com/CUI/WebCastEventDetails.aspx?EventID=1032297841&EventCategory=5&amp;culture=en-US&CountryCode=US">a webcast</a>, and I'd recommend it to anyone who is involved in software development, even if they don't think of themselves as architects.  There is always a point when I'm reading or listening to high level stuff like this where I begin to wonder if it really matters but when it is kept concrete like this the distinction between architecture as high level thinking that has to be done anyway, and architecture as romantic "rah rah" for the higher ups is very clear.<br /><br /><a href="http://blogs.tedneward.com/">Ted's blog</a> seems fairly alive but <a href="http://blogs.prenia.com/cathi/">Cathi's blog</a> has not been updated for a while. <br /><br /><span style="color: rgb(51, 51, 255);font-size:180%;" >}</span></div>
